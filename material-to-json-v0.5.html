<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0 initial-scale=1.0">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <meta name="description" contents="Real-time Multiplayer 3D Social Web Spaces Network">
    <title>material to IDB/JSON v0.5</title>

    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <link rel="stylesheet" href="/css/bootbox-dialoges.css">
    <link rel="stylesheet" href="/css/side-panels.css">
    <link rel="stylesheet" href="/css/messg.css" >
    <link rel="stylesheet" href="/css/spectrum.css">
    <link rel="stylesheet" href="/css/colorpicker.css">
    <link rel="stylesheet" href="/css/spinner.css">
    <link rel="stylesheet" href="/css/jquery-ui.css">
    <link rel="stylesheet" href="/css/alerts.css">
    <link rel="stylesheet" href="/css/panel-ui.css">
    <link rel="stylesheet" href="/css/anywhere3d.css">
    <link rel="stylesheet" href="/css/joystick.css">
    <link rel="stylesheet" href="/css/jquery.Jcrop.css">
    <link rel="stylesheet" href="/css/menu-menubar.css">
    <link rel="stylesheet" href="/css/index.css">

    <script>
        debugMode = true;
        normalPixel = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mPkqf//HwAEtAKL6CdQMgAAAABJRU5ErkJggg==";
    </script>

</head>

<body>

<section class="mbr-section" id="body-section">

    <div id="render-container" class="mbr-overlay"></div>

    <div class="joystick-controls" id="joystick-controls-1"></div>
    <div class="joystick-controls" id="joystick-controls-2"></div>

    <div class="side-panel" id="right-side" style="top:0;">
        <div id="right-side-pinbtn" title="click this to pin/unpin panel"></div>

        <div id="right-side-content" style="overflow-x:hidden;">

            <div class="side-holder" style="margin-bottom:20px;">
                <ul class="nav nav-tabs nav-pills" style="width:300px;">
                    <li class role="presentation"><a href="#control-tab" data-toggle="pill" class="pills right-pill right-pill-controls">Control</a></li>
                    <li class role="presentation"><a href="#assets-tab"  data-toggle="pill" class="pills right-pill right-pill-assets">Assets</a></li>
                    <li class role="presentation"><a href="#helpers-tab" data-toggle="pill" class="pills right-pill right-pill-helpers">Helpers</a></li>
                    <li class role="presentation"><a href="#setup-tab" data-toggle="pill" class="pills right-pill right-pill-setup">Setup</a></li>
                </ul>
            </div>

            <div id="right-side-panel" class="tab-content">

                <div id="control-tab" class="component-pane tab-pane fade in active"></div>
                <div id="assets-tab"  class="component-pane tab-pane fade"></div>
                <div id="helpers-tab" class="component-pane tab-pane fade"></div>
                <div id="setup-tab" class="component-pane tab-pane fade"></div>

            </div>

        </div>

    </div>

    <div class="middle" id="dialog-panel">
        <div id="dialog-container" style="max-width:350px;max-height:600px;"></div>
    </div>

</section>

<script src="/js/w3.js"></script>
<script src="/js/rawinflate.js"></script>
<script src="/js/rawdeflate.js"></script>

<script src="/js/Objectid.js"></script>
<script src="/js/zangodb.min.js"></script>

<script src="/js/jquery.min.js"></script>
<script src="/js/jquery-ui.js"></script>
<script src="/js/jquery.Jcrop.js"></script>
<script src="/js/bootbox.min.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/store2.js"></script>
<script src="/js/spectrum.js"></script>
<script src="/js/validator.min.js"></script>

<script src="/js/alerts.js"></script>
<script src="/js/side-panels.js"></script>
<script src="/js/DeviceDetector.js"></script>
<script src="/js/MathDecimalAdjustment.js"></script>
<script src="/js/watermark.js"></script>
<script src="/js/helpers.js"></script>

<script src="/three/three.js"></script>
<script src="/three/EditorControls.js"></script>
<script src="/three/Detector.js"></script>
<script src="/three/Projector.js"></script>
<script src="/three/Animation.js"></script>
<script src="/three/AnimationHandler.js"></script>
<script src="/three/KeyFrameAnimation.js"></script>
<script src="/three/UVsDebug.js"></script>
<script src="/three/shader.js"></script>

<script src="/js/MW.js"></script>
<script src="/js/MWtps.js"></script>
<script src="/js/VirtualInput.js"></script>
<script src="/js/scene-helpers.js"></script>
<script src="/js/edges-helpers.js"></script>
<script src="/js/scene.js"></script>
<script src="/js/world.js"></script>

<script src="/js/AW3D-v0.2.9.js"></script>

<script>

//  src="/js/PlayerController.js">

    var Player = function(){

        this.getdata = function( socket ){
            if ( !socket ) return;
            var data = {};
            data.playerid  = socket.id;
            data.nickname  = this.nickname;
            data.gender    = this.outfit.getGender();
            data.direction = this.outfit.direction.rotation.y;
            data.position  = this.outfit.direction.position.toArray();
            data.dna       = this.outfit.toDNA();
            debugMode && console.log("player data:", data);
            return data;
        };

    //  Remote player set data.
        this.setdata = function( data ){
            if ( !data.playerid || data.playerid != this.playerid ) return;

            this.playerid = data.playerid;
            this.nickname = data.nickname;
            this.outfit.setGender( data.gender );
            this.outfit.direction.rotation.y = data.direction;
            this.outfit.direction.position.fromArray(data.position);

            if (data.action != undefined) {
                this.outfit.AnimationsHandler.stop();
                this.outfit.AnimationsHandler.play( data.action );
            }
        };

        this.fromDNA = function( dna ){
            var frontAngle = Math.PI - cameraControls.getFrontAngle(); // face front.
            this.controller.direction = frontAngle;
            this.outfit.fromDNA( dna );
            scene.add(this.outfit.direction);
            this.outfit.update();
        };

    };

    var localPlayer = new Player();
    
    localPlayer.holder = AW3D.PlayerHolder(); // IMPORTANT //
    localPlayer.holderHelper = AW3D.PlayerHolderHelper();
    scene.add( localPlayer.holder, localPlayer.holderHelper );

    localPlayer.outfit = AW3D.Outfit( localPlayer ); // IMPORTANT //
    debugMode && console.log( "localPlayer.outfit:", localPlayer.outfit );

    
//  MW TPS cameraControl.

    var cameraControls = new MW.TPSCameraControl(camera, localPlayer.holder, {
        el: renderer.domElement,               // html renderer element.
        offset: new THREE.Vector3( 0, 15, 0 ), // camera eye height.
        radius: 40,                            // default: 37 // (distance of the character to the camera).
        minRadius: 6,                          // default: 10 // (can take and negative values, yes!!!).
        maxRadius: 100,                        // default: 64, runtime: 40.
        rigidObjects: [],                      // collition objects for the camera.
    });

    cameraControls.getforward = function(){ return -this.theta };
    cameraControls.setVerticalOffset = function(offset){ this.offset.y = offset; };
    (cameraControls.frontAngleUpdate = function(){
        windowAnimationFrameRequestID = requestAnimationFrame( cameraControls.frontAngleUpdate );
        cameraControls.forward = -cameraControls.theta;
    })();


//  AW3D PlayerController.

    localPlayer.controller = new MW.CharacterController( localPlayer.holder, localPlayer.radius );
    localPlayer.controller.radius = 3;  // VERY IMPORTANT //
    localPlayer.controller.center.set(-100, 1, 200);
    debugMode && console.log( "initial position:", localPlayer.controller.center );

    localPlayer.sphere = AW3D.PlayerSphere();
    localPlayer.sphere.position.y = 12;
    localPlayer.holder.add( localPlayer.sphere ); 

    localPlayer.controller.isWalking = false;
    localPlayer.controller.getdata = function( action ){

        var data = {};
        data.playerid = socket.id;
        data.radius = this.radius;
        data.isGrounded = this.isGrounded;
        data.isOnSlope = this.isOnSlope;
        data.isIdling  = this.isIdling;
        data.isJumping = this.isJumping;
        data.isRunning = this.isRunning;
        data.isWalking = this.isWalking;
        data.direction = this.direction;
        data.movementSpeed = this.movementSpeed;
        data.jumpStartTime = this.jumpStartTime;
        data.position = this.center.toArray();
        if (!!action) data.action = action;

        return data;
    };

    world.add( localPlayer.controller ); // !important

    localPlayer.controller.addEventListener("startIdling",  onStartIdling);
    localPlayer.controller.addEventListener("startRunning", onStartRunning);
    localPlayer.controller.addEventListener("startJumping", onStartJumping);
    localPlayer.controller.addEventListener("endJumping",   onEndJumping);
    localPlayer.controller.addEventListener("startSliding", onStartSliding);
    localPlayer.controller.addEventListener("startFalling", onStartFalling);


    function startAction( running, walking, idling, speed, name, eventType ){

        localPlayer.outfit.AnimationsHandler.stop();        
        localPlayer.controller.isRunning = running;
        localPlayer.controller.isWalking = walking;
        localPlayer.controller.isIdling  = idling;
        localPlayer.controller.movementSpeed = speed;
        localPlayer.outfit.AnimationsHandler.play( name );
        localPlayer.controller.dispatchEvent({type: eventType});

    }

    function getActionData( name ){
        return {
            playerid : socket.id,
            direction: localPlayer.outfit.direction.rotation.y,
            position : localPlayer.outfit.direction.position.toArray(),
            action   : name,
        };
    }

    function onEndJumping(){

        localPlayer.outfit.AnimationsHandler.weightOn("idle", "walk", "run");

        if ( localPlayer.controller.isRunning && localPlayer.controller.isWalking ) {

            localPlayer.outfit.AnimationsHandler.stop();
            //localPlayer.controller.isRunning = true;
            //localPlayer.controller.isWalking = true;
            //localPlayer.controller.isIdling  = false;
            localPlayer.controller.movementSpeed = 28;
            localPlayer.outfit.AnimationsHandler.play("walk");
            localPlayer.controller.dispatchEvent({type:"startRunning"});

        } else if ( localPlayer.controller.isRunning && !localPlayer.controller.isWalking ) {

            localPlayer.outfit.AnimationsHandler.stop();
            //localPlayer.controller.isRunning = true;
            //localPlayer.controller.isWalking = false;
            //localPlayer.controller.isIdling  = false;
            localPlayer.controller.movementSpeed = 45;
            localPlayer.outfit.AnimationsHandler.play("run");
            localPlayer.controller.dispatchEvent({type:"startRunning"});

        } else {

            localPlayer.outfit.AnimationsHandler.stop();
            //localPlayer.controller.isRunning = false;
            //localPlayer.controller.isWalking = false;
            //localPlayer.controller.isIdling  = true;
            localPlayer.controller.movementSpeed = 0;
            localPlayer.outfit.AnimationsHandler.play("idle");
            localPlayer.controller.dispatchEvent({type:"startIdling"});

        }

    }

    function onStartIdling(){
        //  debugMode && console.log( "localPlayer.controller:", "startIdling:" );
    }

    function onStartRunning(){
        //  debugMode && console.log( "localPlayer.controller:", "startRunning:" );
    }

    function onStartJumping(){
        localPlayer.outfit.AnimationsHandler.weightOff("idle", "walk", "run");
    }

    function onStartSliding(){
        //  debugMode && console.log( "localPlayer.controller:", "startSliding:" );
    }
    
    function onStartFalling(){
        //  debugMode && console.log( "localPlayer.controller:", "startFalling:" );
    }

</script>

<script>

//  src = "/js/KeyInputControls.js">

    var keyInputControls = new MW.KeyInputControl();

    keyInputControls.On = function(){
        if ( !keyInputControls.isOff ) return;
        $(keyInputControls).on( "movekeyon", onMoveKeyOn );
        $(keyInputControls).on( "movekeyoff", onMoveKeyOff );
        $(keyInputControls).on( "jumpkeypress", onJumpInput );
        $(keyInputControls).on( "movekeychange", onMoveKeyChange );
        keyInputControls.isOff = false;
        debugMode && console.log( "keyInputControls are ON." );
    };

    keyInputControls.Off = function(){
        if ( keyInputControls.isOff ) return;
        $(keyInputControls).off( "movekeyon", onMoveKeyOn );
        $(keyInputControls).off( "movekeyoff", onMoveKeyOff );
        $(keyInputControls).off( "jumpkeypress", onJumpInput );
        $(keyInputControls).off( "movekeychange", onMoveKeyChange );
        keyInputControls.isOff = true;
        debugMode && console.log( "keyInputControls are OFF." );
    };

    keyInputControls.update = function(){
        if ( keyInputControls.isOff ) return;
        if ( keyInputControls.isMoveKeyHolded 
          || localPlayer.controller.isJumping 
          || !localPlayer.controller.isGrounded 
          || localPlayer.controller.isOnSlope ){

            this.dispatchEvent({type:"update"});
        }
    };

    keyInputControls.Off(); 
    keyInputControls.inRun = true;

    function onMoveKeyOn() { 

        if ( !!AnimationPanelControls ) {
            AnimationPanelControls.isActive = false;
        }

        if (  localPlayer.controller.isJumping 
          || !localPlayer.controller.isGrounded 
          ||  localPlayer.controller.isOnSlope ) {
            return;
        }

        localPlayer.controller.direction = (2 * Math.PI) - cameraControls.getFrontAngle() + this.frontAngle;

        localPlayer.outfit.AnimationsHandler.stop();
        localPlayer.controller.isRunning = true; 
        localPlayer.controller.isWalking = true;
        localPlayer.controller.movementSpeed = 28;
        localPlayer.outfit.AnimationsHandler.play("walk");

    }

    function onMoveKeyChange() {
        localPlayer.controller.direction = (2 * Math.PI) - cameraControls.getFrontAngle() + this.frontAngle;
    }

    function onMoveKeyOff() {

        if (  localPlayer.controller.isJumping 
          || !localPlayer.controller.isGrounded 
          ||  localPlayer.controller.isOnSlope ) {
            return;
        }

        var finalDirection = (2 * Math.PI) - cameraControls.getFrontAngle() + this.frontAngle;

        localPlayer.controller.direction = finalDirection;
        localPlayer.outfit.AnimationsHandler.stop();
        localPlayer.controller.isRunning = false;
        localPlayer.controller.isWalking = false;
        localPlayer.controller.isIdling  = true;
        localPlayer.controller.movementSpeed = 0;
        localPlayer.outfit.AnimationsHandler.play("idle");
        localPlayer.controller.dispatchEvent({type:"startIdling"});

    }

    function onJumpInput() {

        if (  localPlayer.controller.isJumping 
          || !localPlayer.controller.isGrounded 
          ||  localPlayer.controller.isOnSlope ) {
            return;
        }

        localPlayer.controller.jump();
        localPlayer.outfit.AnimationsHandler.jump();

    }

</script>

<script>

//  src="/js/JoystickControls.js">

//  MW Joystick Controls.
    var joystick1Selector  = "#joystick1";
    var joystick2Selector  = "#joystick2";
    var jumpButtonSelector = "#jumpButton";
    var joystickControlsSelector  = ".joystick-controls";
    var joystickControls1Selector = "#joystick-controls-1";
    var joystickControls2Selector = "#joystick-controls-2";
    var buttonSvgSrc = [
      '<svg width="48" height="48" viewBox="0 0 64 64">',
        '<path fill="#fff" d="M44.5,54.5c-0.3-5.1-2.4-9.4-5.7-13.2C41,36,40.9,30,38.5,24.7c-1.2-2.7-3.9-4.4-6.9-3.3c-0.2,0.1-0.4,0.1-0.5,0.2c-3-4.3-6.6-8.3-10.1-11.8c-2.6-2.6-6.4,1.7-3.8,4.3c3.9,3.9,8.1,8.5,11,13.7c0,0.1,0.1,0.3,0.2,0.4c1.5,3.2,1.9,6.4,0.2,9.6c-0.3,0.5-0.4,1-0.5,1.5c-1.1,1.5-2.3,3-3.6,4.4c-0.8-2.3-1.4-4.7-1.6-7.1c-0.5-4.6-7.7-4.1-7.2,0.5c0.5,4.9,2.1,9.6,3.9,14.2c0.8,1.9,3.6,3.4,5.4,1.8c2.8-2.4,5.3-4.9,7.5-7.8c0.2,0.1,0.5,0.1,0.7,0.1c0.1,0.3,0.3,0.5,0.5,0.7c1.7,1.8,2.8,3.9,3.3,6.3c-2.2,0.8-4.6,1.4-7,1.4c-4.6,0.1-4.1,7.2,0.5,7.2c4-0.1,7.9-1.3,11.6-3C43.6,57.5,44.6,56.2,44.5,54.5z M34.2,8.9c0.7,0.1,1.6-0.1,2.3,0.3c1.5,0.8,2.6,2.1,3.2,3.6c0.2-2.2,0.5-4.3,0.8-6.5c0.5-3.7-5.1-4.7-5.7-1.1C34.6,6.3,34.3,7.8,34.2,8.9z"/>',
        '<circle fill="#fff" cx="33.8" cy="15.2" r="4.9"/>',
      '</svg>'
    ].join('');

    var joystick1  = new virtualInput.Joystick( $( joystickControls1Selector ), 120, { id: "joystick1" } );
    var joystick2  = new virtualInput.Joystick( $( joystickControls2Selector ), 120, { id: "joystick2" } );
    var jumpButton = new virtualInput.Button( $( joystickControls1Selector ),    70, { id: "jumpButton", label: "<b>JUMP</b>" } ); // buttonSvgSrc

    joystick1.addEventListener( "active", function () { 
        try { AnimationPanelControls.isActive = false; } catch(err){;}  // !important

        if (  localPlayer.controller.isJumping 
          || !localPlayer.controller.isGrounded 
          ||  localPlayer.controller.isOnSlope ) {
            return;
        }

        localPlayer.controller.direction = (3 * Math.PI/2) - cameraControls.getFrontAngle() + this.angle; // !important
/*
        if ( localPlayer.controller.isRunning && !localPlayer.controller.isWalking ) {

            localPlayer.outfit.AnimationsHandler.stop();
            localPlayer.controller.movementSpeed = 45;
            localPlayer.outfit.AnimationsHandler.play("run");

        } else {

            localPlayer.outfit.AnimationsHandler.stop();
            localPlayer.controller.isRunning = true; 
            localPlayer.controller.isWalking = true;
            localPlayer.controller.movementSpeed = 28;
            localPlayer.outfit.AnimationsHandler.play("walk");

        }
*/
        localPlayer.outfit.AnimationsHandler.stop();
        localPlayer.controller.isRunning = true; 
        localPlayer.controller.isWalking = false;
        localPlayer.controller.movementSpeed = 45;
        localPlayer.outfit.AnimationsHandler.play("run");

    });

    joystick1.addEventListener( "disactive", function () { 

        if (  localPlayer.controller.isJumping 
          || !localPlayer.controller.isGrounded 
          ||  localPlayer.controller.isOnSlope ) {
            return;
        }

        localPlayer.outfit.AnimationsHandler.stop();
        localPlayer.controller.isRunning = false;
        localPlayer.controller.isWalking = false;
        localPlayer.controller.isIdling  = true;
        localPlayer.controller.movementSpeed = 0;
        localPlayer.outfit.AnimationsHandler.play("idle");
        localPlayer.controller.dispatchEvent({type:"startIdling"});

    });

    joystick1.update = function(){

        if ( this.isActive ) {

            localPlayer.controller.direction = (3 * Math.PI/2) - cameraControls.getFrontAngle() + this.angle;

            this.dispatchEvent({type:"update"}); // IMPORTANT //

        }
    };

    joystick2.update = function(){

        if ( this.isActive ) {

            cameraControls.setLatLon(
                cameraControls.lat + this.position.y * 0.5, // deg.
                cameraControls.lon - this.position.x        // deg.
            );

            this.dispatchEvent({type:"update"}); // IMPORTANT //
        }
    }

    jumpButton.addEventListener( "press", function () { 

        if (  localPlayer.controller.isJumping 
          || !localPlayer.controller.isGrounded 
          ||  localPlayer.controller.isOnSlope ) {
            return;
        }

        localPlayer.controller.jump();
        localPlayer.outfit.AnimationsHandler.jump();
    });

</script>

<script src="/animations/animationsLoader.js"></script>
<script src="/js/jquery-update-engine.js"></script>
<script src="/js/jquery-render-engine.js"></script>

<script>

//  src="/js/runtime.js">

    var mouse = new THREE.Vector2();

    var rendererHalfWidth  = renderer.domElement.width * 0.5;
    var rendererHalfHeight = renderer.domElement.height * 0.5;

//  LocalPlayer.
    localPlayer.holder.visible = true;
    localPlayer.controller.center.set(0,1,0);
//  localPlayer.controller.direction = Math.PI;

//  Scene.
    scene.background = new THREE.Color(0xb1c8e8);
    scene.add( localPlayer.outfit.direction );
    sunLight.target = localPlayer.outfit.direction; // !important

//  Camera controls.
    cameraControls.radius    = 46;
    cameraControls.offset.y  = 16;
    cameraControls.minRadius =  6;
    cameraControls.maxRadius = 300;

//  runtime.

    var renderClock = new THREE.Clock();
    var updateClock = new THREE.Clock();

    var $render = $("input[type=hidden].render");
    var $update = $("input[type=hidden].update");

    animate();
    updates();

    function animate(){

        windowAnimationFrameRequestID = requestAnimationFrame( animate );

    //  render();

        for (var i = 0; i < $render.length; i++){
            $render[i].render();
        }

    }

    function updates(){

        windowAnimationFrameRequestID = requestAnimationFrame( updates );

    //  update();
        
        var dt = updateClock.getDelta();
        var time = updateClock.getElapsedTime();

        for ( var i = 0; i < $update.length; i++ ){
            $update[i].update( dt );
        }

    }

//  Event Listeners.

    $(window).on( "resize", onWindowResize );
    function onWindowResize() {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( container.clientWidth, container.clientHeight );
        rendererHalfWidth = renderer.domElement.width * 0.5;
        rendererHalfHeight = renderer.domElement.height * 0.5;
    }

    $(window).on( "mousemove", onMouseMove );
    function onMouseMove(e) {
        mouse.x = ( e.clientX - rendererHalfWidth );
        mouse.y = ( e.clientY - rendererHalfHeight );
    }

</script>






<script>

    var threedb_vers = 1;          // deprecated.
    var threedb_name = "THREE_DB"; // deprecated.

    var three_db = new zango.Db( threedb_name, threedb_vers, {
        assets: true,
        matcaps: true,
        avatars: true,
        female: true,
        male: true,
        geometries: true,
        materials: true,
        textures: true,
        images: {uuid: true},
    });

    three_db.open(function(err, database){
        if (err) console.error(err);
    }).then( function(){
        debugMode && console.log(
        `Database ${three_db.name} ready for use.`);
    }).catch(function(err){
        console.error(err);
    });

</script>

<script>

    var dev_vers = 1;
    var dev_name = "dev_DB";

    var db = new zango.Db( dev_name, dev_vers, {

        male:   ["uuid", "name"],
        female: ["uuid", "name"],
        assets: ["uuid", "name"],

        avatars: ["uuid", "name"],
        outfits: ["uuid", "name"],
        matcaps: ["uuid", "name", "url"],

        images:     ["uuid", "name", "url"],
        textures:   ["uuid", "name", "sourceFile"],
        materials:  ["uuid", "name"],
        geometries: ["uuid", "name"],

    });

    db.open(function(err, database){
        if (err) console.error(err);
    }).then( function(){
        debugMode && console.log(
        `Database ${db.name} ready for use.`);
    }).catch(function(err){
        console.error(err);
    });

</script>

<script>


    three_db.collection("female").findOne({_id:"body"}).then(function(json){
        localPlayer.outfit.add( {body: initSkinnedAsset( json )} );
    }).then( function(){
        return three_db.collection("female").findOne({_id:"underwears"});
    }).then(function(json){
        localPlayer.outfit.add( {lingerie: initSkinnedAsset( json )} );
    }).then( function(){
        return three_db.collection("female").findOne({_id:"stockings"})
    }).then(function(json){
        localPlayer.outfit.add( {stocking: initSkinnedAsset( json )} );
    }).then(function(){
        localPlayer.holder.visible = false;
    }).then(function(){

        var loader = new THREE.TextureLoader();

        localPlayer.outfit.body.material.materials[0].map = loader.load("https://i.imgur.com/pRYCYkb.jpg");
        localPlayer.outfit.body.material.materials[0].emissiveMap = loader.load("https://i.imgur.com/jc8chBX.jpg");
        localPlayer.outfit.body.material.materials[0].color.setHex(16777215);
        localPlayer.outfit.body.material.materials[0].emissive.setHex(11776690);

        localPlayer.outfit.body.material.materials[1].map = 
        localPlayer.outfit.body.material.materials[1].emissiveMap = loader.load("https://i.imgur.com/Si5QWl0.png");
        localPlayer.outfit.body.material.materials[1].color.setHex(16777215);
        localPlayer.outfit.body.material.materials[1].emissive.setHex(9276813);

        localPlayer.outfit.body.material.materials[0].needsUpdate = true;
        localPlayer.outfit.body.material.materials[1].needsUpdate = true;

    });

    function initSkinnedAsset( json, url ){

        var loader = new THREE.JSONLoader();
        var object = loader.parse( json );

    //  Material.

        if ( !!object.materials ) {

            object.materials.forEach( function ( material ) {
                material.skinning = true;     // !important
            }); 
        }

    //  Switching to multimaterials.

        if ( !!object.materials && object.materials.length > 0 ) {

            var multimaterial = new THREE.MeshFaceMaterial( object.materials );  // <-- MultiMaterial.
            for (var i = 0; i < multimaterial.materials.length; i++){
                if ( !multimaterial.materials[i].skinning ) {
                    multimaterial.materials[i].skinning = true;                  // !important
                }
            }

        } else {

            var multimaterial = new THREE.MeshFaceMaterial([
                new THREE.MeshStandardMaterial({skinning:true})
            ]);
        }

        if ( !multimaterial ) console.error("MultiMaterial did not defined:", multimaterial);

    //  Geometry.

        var geometry = object.geometry;
        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        geometry.computeBoundingBox();
        geometry.computeBoundingSphere();
        geometry.name = json.name;

        if ( !!json.sourceFile ) {
            geometry.sourceFile = json.sourceFile;  // IMPORTANT //
        } else if ( !!url ) {
            geometry.sourceFile = url;              // IMPORTANT //
        }

    //  Skinned mesh.

        var skinned = new THREE.SkinnedMesh( geometry, multimaterial );

        skinned.renderDepth = 1;
        skinned.frustumCulled = false;              // IMPORTANT //
        skinned.scale.set( 1, 1, 1 );
        skinned.position.set( 0, 0, 0 );
        skinned.rotation.set( 0, 0, 0 ); 

        return skinned;
    }

    function makePowerOfTwo( image, natural ) {
        var canvas = document.createElement( "canvas" );

        if ( natural ){
            canvas.width = THREE.Math.nearestPowerOfTwo( image.naturalWidth );
            canvas.height = THREE.Math.nearestPowerOfTwo( image.naturalHeight );
        } else {
            canvas.width = THREE.Math.nearestPowerOfTwo( image.width );
            canvas.height = THREE.Math.nearestPowerOfTwo( image.height );
        }
        var context = canvas.getContext( "2d" );
        context.drawImage( image, 0, 0, canvas.width, canvas.height );

    //  debugMode && console.warn( "outfitLoader:makePowerOfTwo(img):", 
    //  "Image resized to:", canvas.width, "x", canvas.height );

        return canvas;
    }

    function getDataURL( image ) {

        var canvas;

        if ( image.toDataURL !== undefined ) {

            canvas = image;

        } else {

            canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
            canvas.width = image.width;
            canvas.height = image.height;

            canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

        }

        if ( canvas.width > 2048 || canvas.height > 2048 ) {

            return canvas.toDataURL( 'image/jpeg', 0.6 );

        } else {

            return canvas.toDataURL( 'image/png' );

        }

    }

/*
//  RESPONSE IMAGE TO DATAURL.
    fetch("https://i.imgur.com/pRYCYkb.jpg")
    .then(function(response){
        return response.blob();
    }).then(function(blob){
        return new Promise(function(resolve){
            var reader = new FileReader();
            reader.addEventListener("loadend", function(e){
                resolve( reader.result );
            });
            reader.readAsDataURL(blob);
        });
    }).then(function(data){
        console.log(data);
    });
*/

</script>

<script>

//  ZANGO DB (INDEXED DB).

//  Inserts and gets material,texture,image to and from
//  zango indexedDB. Breaks materials to material options
//  and textures, and breaks textures to texture options
//  and images with primary key _id: uuid.
//  Material options stored in "materials" collection,
//  Textures options stored in "textures" collection,
//  and texture images stored in "images" collection.
//  On getting from indexedDB, material pull textures
//  from "textures" collection, and textures pull images,
//  from "images" collection using uuid.



//  MATERIAL TO INDEXED DB.
//  Inserts the material to indexedDB and 
//  returns a promise with material uuid resolved.

    function materialtoIDB( material ){


        var IMAGES = db.collection("images");
        var TEXTURES = db.collection("textures");
        var MATERIALS = db.collection("materials");


    //  MULTIMATERIAL.

        if ( material.type == "MultiMaterial" ) {

            return MATERIALS.findOne({uuid: material.uuid}, function(err){
                if (err) throw err;
            }).then(async function(result){


            //  multimaterial already exists.

                if ( !!result ) {

                    debugMode && console.warn(`Multimaterial ${result.uuid} already exists in materials collection:`, result);

                    return result.uuid;
                }


            //  multimaterial to json.

                var json = {

                    name: "",
                    type: material.type,
                    uuid: material.uuid || THREE.Math.generateUUID(),
                    _id:  material.uuid,

                };


            //  named multimaterial.

                while ( json.name.length < 4 ) {

                    json.name = json._id = prompt(
                        `Please type a material name (required):`
                        + `\nName must be four (4) characters length at least`,
                        material.name || "untitled material"
                    );

                //  Abort.

                    if ( json.name == null ) {
                        console.warn(`Multimaterial save canceled by the user.`);
                        return;
                    }

                }


            //  insert materials to db.

                json.materials = [];

                for ( var i = 0; i < material.materials.length; i++ ){

                    await materialtoIDB( material.materials[i] )
                    .then(function( uuid ){
                        json.materials.push( uuid );
                    });

                }


            //  insert multimaterial to db.

                return MATERIALS.insert(json, function(err){
                    if (err) throw err;
                }).then(function(){
                    return json.uuid;
                }).catch(function(err){
                    console.error(err);
                });


            }).catch(function(err){
                console.error(err);
            });

        }

    //  MATERIAL.

        return MATERIALS.findOne({name: material.name}, function(err){
            if (err) throw err;
        }).then(async function(result){
        //  debugMode && console.log( "material result:", result );


        //  material already exists.

            if ( !!result ) {

                debugMode && console.warn(`Material ${result.uuid} already exists in materials collection:`, result);

                return result.uuid;
            }


        //  material to json.

            var json = {};

            for ( var name in material ){

                if ( material[ name ] == undefined ) continue;
                if ( material[ name ] instanceof Function ) continue;


                switch( name ){

                    case "defines":
                    case "program":
                    case "_listeners":
                    case "needsUpdate":
                    case "_needsUpdate":
                    case "__webglShader":
                    break;


                //  uuid & _id.

                    case "uuid":
                        json._id = json.uuid = material.uuid || THREE.Math.generateUUID();
                    break;


                //  Replace _id with material name.

                    case "name":
                        if ( !!material[ name ] ) json._id = json[ name ] = material[ name ];
                    break;


                //  default.

                    default:
                        json[ name ] = material[ name ];
                    break;


                //  texture to json.

                    case "alphaMap":
                    case "aoMap":
                    case "bumpMap":
                    case "displacementMap":
                    case "emissiveMap":
                    case "lightMap":
                    case "map":
                    case "metalnessMap":
                    case "normalMap":
                    case "roughnessMap":
                    case "specularMap":

                        if ( !(material[ name ] instanceof THREE.Texture) ) {
                            throw `${name} is not instance of THREE.Texture`;
                        }

                        await texturetoIDB( material[ name ] )
                        .then(function( uuid ){
                            json[ name ] = uuid;
                        }).catch(function(err){
                            console.error(err);
                        });

                    break;


                //  three color to hex.

                    case "color":
                    case "emissive":
                    case "specular":

                        if ( !(material[ name ] instanceof THREE.Color) ) {
                            throw `${name} is not instance of THREE.Color`;
                        }

                        json[ name ] = material[ name ].getHex();

                    break;


                //  vector2 to array.

                    case "normalScale":

                        if ( !(material[ name ] instanceof THREE.Vector2) ) {
                            throw `${name} is not instance of THREE.Vector2`;
                        }

                        json[ name ] = material[ name ].toArray();

                    break;


                //  cube texture (TODO).

                    case "envMap":

                        // TODO //

                    break;

                }

            }


            debugMode && console.log( "material to indexedDB:", json );


        //  insert material to db.

            return MATERIALS.insert(json, function(err){
                if (err) throw err;
            }).then(function(){
                return json.uuid;
            }).catch(function(err){
                console.error(err);
            });


        }).catch(function(err){
            console.error(err);
        });

    }


//  MATERIAL FROM INDEXED DB.
//  Creates a material from indexedDB and 
//  returns a promise with the material resolved.

    async function materialfromIDB( uuid ){


        var IMAGES = db.collection("images");
        var TEXTURES = db.collection("textures");
        var MATERIALS = db.collection("materials");


        return MATERIALS.findOne({uuid:uuid}, function(err){
            if (err) throw err;
        }).then(async function( result ){


        //  Abort.

            if (!result) {

                debugMode && console.warn(
                    `Material ${uuid} not found in materials collection.`);
                return;
            }


        //  MULTIMATERIAL.

            if ( result.type == "MultiMaterial" ) {


                var materials = [];

                for ( var i = 0; i < result.materials.length; i++ ){

                    await materialfromIDB( result.materials[i] )
                    .then(function( material ){
                        materials.push( material );
                    });

                }

                debugMode && console.log("materials from indexedDB:", materials);


            //  Create multimaterial.

                var multimaterial = new THREE.MeshFaceMaterial(materials);

                multimaterial.uuid = result.uuid;

                debugMode && console.log("multimaterial from indexedDB:", multimaterial);

                return multimaterial;

            }


        //  MATERIAL.

            var options = {};

            for (var name in result){


                switch (name){

                    case "_id":
                    break;


                //  uuid.

                    case "uuid":
                        options.uuid = result.uuid || THREE.Math.generateUUID();
                    break;


                //  default.

                    default:
                        options[ name ] = result[ name ];
                    break;


                //  texture from json.

                    case "alphaMap":
                    case "aoMap":
                    case "bumpMap":
                    case "displacementMap":
                    case "emissiveMap":
                    case "lightMap":
                    case "map":
                    case "metalnessMap":
                    case "normalMap":
                    case "roughnessMap":
                    case "specularMap":

                        await texturefromIDB( result[ name ] )
                        .then(function( texture ){
                            options[ name ] = texture;
                            debugMode && console.log( `options.${name}:`, options[ name ] );
                        });

                    break;


                //  three color to hex.

                    case "color":
                    case "emissive":
                    case "specular":

                        options[ name ] = new THREE.Color();
                        options[ name ].setHex( result[ name ] );

                    break;


                //  vector2 from array.

                    case "normalScale":

                        options[ name ] = new THREE.Vector2();
                        options[ name ].fromArray( result[ name ] );

                    break;


                //  cube texture (TODO).

                    case "envMap":

                        // TODO //

                    break;

                }

            }


        //  create material from options.
            return new THREE[ options.type ](options);


        }).catch(function(err){
            console.error(err);
        });

    }



//  TEXTURE TO INDEXED DB.
//  Inserts the texture to indexedDB and 
//  returns a promise resolved with texture uuid.

    function texturetoIDB( texture ){


        var IMAGES = db.collection("images");
        var TEXTURES = db.collection("textures");


        return TEXTURES.findOne({uuid: texture.uuid}, function(err){
            if (err) throw err;
        }).then(async function(result){


        //  Abort.

            if ( !!result ) {

                debugMode && console.warn(
                    `Texture ${result.uuid} already exists in textures collection:`, result);
                return result.uuid;
            }


        //  texture to json.

            var json = {};

            for (var name in texture ){

                if ( texture[ name ] == undefined ) continue;
                if ( texture[ name ] instanceof Function ) continue;


                switch (name){

                    case "_listeners":
                    break;


                //  uuid & _id.

                    case "uuid":
                        json._id = json[ name ] = texture[ name ] || THREE.Math.generateUUID();
                    break;


                //  default.

                    default:
                        json[ name ] = texture[ name ];
                    break;


                //  vector2 to array.

                    case "offset":
                    case "repeat":
                        json[ name ] = texture[ name ].toArray();
                    break;


                //  insert image to db.

                    case "image":

                        await imagetoIDB( texture[ name ] )
                        .then(function(uuid){
                            json[ name ] = uuid;
                            debugMode && console.log( `json.${name}:`, uuid );
                        });

                    break;

                }

            }


            debugMode && console.log( "texture to indexedDB:", json );


            return TEXTURES.insert(json, function(err){
                if (err) throw err;
            }).then(function(){
                return json.uuid;
            }).catch(function(err){
                console.error(err);
            });


        }).catch(function(err){
            console.error(err);
        });
    
    }



//  TEXTURE FROM INDEXED DB.
//  Creates a texture from indexedDB and  
//  returns a promise with the texture resolved.

    function texturefromIDB( uuid ){


        var TEXTURES = db.collection("textures");


        return TEXTURES.findOne({uuid:uuid}, function(err){
            if (err) throw err;
        }).then(async function( result ){


        //  Abort.

            if (!result) {

                debugMode && console.warn(
                    `Texture ${uuid} not found in textures collection.`);
                return;
            }


        //  texture from json.

            var texture = new THREE.Texture();

            for ( var name in result ){


                switch (name){

                    case "_id":
                    break;


                //  default.

                    default:
                        texture[ name ] = result[ name ];
                    break;


                //  array to Vector2.

                    case "offset":
                    case "repeat":
                        if ( result[ name ].length != 2) continue;
                        texture[ name ] = new THREE.Vector2();
                        texture[ name ].fromArray( result[ name ] );
                    break;


                //  wrapS & wrapT.

                    case "wrap":
                        if ( result[ name ].length != 2) continue;
                        if ( !(result[ name ] instanceof Array) ) continue;
                        texture.wrapS = result[ name ][0];
                        texture.wrapT = result[ name ][1];
                    break;


                //  image from db.

                    case "image":

                        await imagefromIDB( result.image )
                        .then(function(image){
                            texture[ name ] = image;
                        });

                    break;
                }

            }


            return texture;

        }).catch(function(err){
            console.error(err);
        });

    }


//  IMAGE TO INDEXED DB.
//  Inserts the image to indexedDB and returns a
//  promise resolved with a new uuid of the image.

    function imagetoIDB( image ){


        var IMAGES = db.collection("images");


        var uuid = THREE.Math.generateUUID();

        var json = {
            _id:  uuid,
            uuid: uuid,
            data: getDataURL( image ),
        };


        return IMAGES.insert( json, function(err){
            if (err) throw err;
        }).then(function(){
            return json.uuid;
        }).catch(function(err){
            console.error(err);
        });


        function getDataURL( image ){

            var canvas;

            if ( image.toDataURL !== undefined ) {

                canvas = image;

            } else {

                canvas = document.createElementNS( "http://www.w3.org/1999/xhtml", "canvas" );
                canvas.width = image.width;
                canvas.height = image.height;
                canvas.getContext( "2d" ).drawImage( image, 0, 0, image.width, image.height );

            }

            if ( canvas.width > 2048 || canvas.height > 2048 ) {

                return canvas.toDataURL( "image/jpeg", 0.6 );

            } else {

                return canvas.toDataURL( "image/png" );
            }

        }

    }



//  IMAGE FROM INDEXED DB.
//  Creates an image from indexedDB and
//  returns a promise resolved with the image.

    function imagefromIDB( uuid ){


        var IMAGES = db.collection("images");


        return IMAGES.findOne({uuid: uuid}, function(err){
            if (err) throw err;
        }).then(function( result ){


        //  Abort.

            if ( !result ) {

                debugMode && console.warn(
                    `Image ${uuid} not found in images collection.`);
                return;
            }


        //  image from db.

            var img = new Image();
            img.crossOrigin = "anonymous";
            img.src = result.data;

            return img;


        }).catch(function(err){
            console.error(err);
        });
    
    }

</script>

<script>

//  MATERIAL TO JSON.
//  Return a promise with the 
//  material json object resolved.

    async function materialtoJSON( material ){

    //  MULTIMATERIAL.

        if ( material.type == "MultiMaterial" ) {


        //  multimaterial to json.

            var json = {

                name: "",
                type: material.type,
                uuid: material.uuid || THREE.Math.generateUUID(),

            };


        //  named multimaterial.

            while ( json.name.length < 4 ) {

                json.name = prompt(`Please type a material name (required):`
                    + `\nName must be four (4) characters length at least`,
                    material.name || "untitled material"
                );

            //  Abort.

                if ( json.name == null ) {
                    console.warn(`Multimaterial to json canceled by the user.`);
                    return;
                }

            }


        //  materials to json.

            json.materials = [];

            for ( var i = 0; i < material.materials.length; i++ ){

                await materialtoJSON( material.materials[i] )
                .then(function( jsonMaterial ){
                    json.materials.push( jsonMaterial );
                });

            }


            debugMode && console.log( "multimaterial to json:", json );

            return json;

        }


    //  MATERIAL.

        var json = {};


        for ( var name in material ){

            if ( material[ name ] == undefined ) continue;
            if ( material[ name ] instanceof Function ) continue;


            switch( name ){

                case "defines":
                case "program":
                case "_listeners":
                case "needsUpdate":
                case "_needsUpdate":
                case "__webglShader":
                break;


            //  uuid & _id.

                case "uuid":
                    json.uuid = material.uuid || THREE.Math.generateUUID();
                break;


            //  default.

                default:
                    json[ name ] = material[ name ];
                break;


            //  texture to json.

                case "alphaMap":
                case "aoMap":
                case "bumpMap":
                case "displacementMap":
                case "emissiveMap":
                case "lightMap":
                case "map":
                case "metalnessMap":
                case "normalMap":
                case "roughnessMap":
                case "specularMap":

                    if ( !(material[ name ] instanceof THREE.Texture) ) {
                        throw `${name} is not instance of THREE.Texture`;
                    }

                    await texturetoJSON( material[ name ] )
                    .then(function( jsontexture ){
                        json[ name ] = jsontexture;
                    }).catch(function(err){
                        console.error(err);
                    });

                break;


            //  three color to hex.

                case "color":
                case "emissive":
                case "specular":

                    if ( !(material[ name ] instanceof THREE.Color) ) {
                        throw `${name} is not instance of THREE.Color`;
                    }

                    json[ name ] = material[ name ].getHex();

                break;


            //  vector2 to array.

                case "normalScale":

                    if ( !(material[ name ] instanceof THREE.Vector2) ) {
                        throw `${name} is not instance of THREE.Vector2`;
                    }

                    json[ name ] = material[ name ].toArray();

                break;


            //  cube texture (TODO).

                case "envMap":

                    // TODO //

                break;

            }

        }


        debugMode && console.log( "material to json:", json );

        return json;

    }

    

//  MATERIAL FROM JSON.
//  Return a promise with the material resolved.

    async function materialfromJSON( json ){


   //  MULTIMATERIAL.

       if ( json.type == "MultiMaterial" ) {


           var materials = [];

           for ( var i = 0; i < json.materials.length; i++ ){

               await materialfromJSON( json.materials[i] )
               .then(function( material ){
                   materials.push( material );
               });

           }

           debugMode && console.log("materials from json:", materials);


       //  Create multimaterial.

           var multimaterial = new THREE.MeshFaceMaterial(materials);

           multimaterial.uuid = json.uuid || THREE.Math.generateUUID();

           debugMode && console.log("multimaterial from json:", multimaterial);

           return multimaterial;

        }


    //  MATERIAL.

        var options = {};

        for (var name in json){


            switch (name){


            //  uuid.

                case "uuid":
                    options.uuid = json.uuid || THREE.Math.generateUUID();
                break;


            //  default.

                default:
                    options[ name ] = json[ name ];
                break;


            //  texture from json.

                case "alphaMap":
                case "aoMap":
                case "bumpMap":
                case "displacementMap":
                case "emissiveMap":
                case "lightMap":
                case "map":
                case "metalnessMap":
                case "normalMap":
                case "roughnessMap":
                case "specularMap":

                    await texturefromJSON( json[ name ] )
                    .then(function( texture ){
                        options[ name ] = texture;
                        debugMode && console.log( `options.${name}:`, options[ name ] );
                    });

                break;


            //  three color to hex.

                case "color":
                case "emissive":
                case "specular":

                    options[ name ] = new THREE.Color();
                    options[ name ].setHex( json[ name ] );

                break;


            //  vector2 from array.

                case "normalScale":

                    options[ name ] = new THREE.Vector2();
                    options[ name ].fromArray( json[ name ] );

                break;


            //  cube texture (TODO).

                case "envMap":

                    // TODO //

                break;

            }

        }


        return new THREE[ options.type ](options);

    }


//  TEXTURE TO JSON.
//  Return a promise resolved 
//  with the texture json object.

    async function texturetoJSON( texture ){

        var json = {};

        for (var name in texture ){

            if ( texture[ name ] == undefined ) continue;
            if ( texture[ name ] instanceof Function ) continue;


            switch (name){

                case "_listeners":
                break;


            //  uuid.

                case "uuid":
                    json[ name ] = texture[ name ] || THREE.Math.generateUUID();
                break;


            //  default.

                default:
                    json[ name ] = texture[ name ];
                break;


            //  vector2 to array.

                case "offset":
                case "repeat":
                    json[ name ] = texture[ name ].toArray();
                break;


            //  image to json.

                case "image":

                    await imagetoJSON( texture[ name ] )
                    .then(function( jsonImage ){
                        json[ name ] = jsonImage;
                    });

                break;

            }

        }

        return json;

    }


//  TEXTURE FROM JSON.
//  Return a promise with the texture resolved.

    async function texturefromJSON( json ){

        var texture = new THREE.Texture();

        for ( var name in json ){


            switch (name){


            //  default.

                default:
                    texture[ name ] = json[ name ];
                break;


            //  array to vector2.

                case "offset":
                case "repeat":

                    if ( json[ name ].length != 2) break;

                    texture[ name ] = new THREE.Vector2();
                    texture[ name ].fromArray( json[ name ] );

                break;


            //  wrapS & wrapT.

                case "wrap":

                    if ( json[ name ].length != 2) break;
                    if ( !( json[ name ] instanceof Array ) ) break;

                    texture.wrapS = json[ name ][0];
                    texture.wrapT = json[ name ][1];

                break;


            //  image from db.

                case "image":

                    texture[ name ] = getImage();

                    function getImage(){

                        var img = new Image();
                        img.crossOrigin = "anonymous";

                        img.addEventListener("load", function(){
                            texture.needsUpdate = true;
                        });

                        img.src = json.image.data;

                        return img;
                    }

                break;

            }

        }

        return texture;

    }



//  IMAGE TO JSON.
//  Return a promise with the 
//  image json object resolved.

    async function imagetoJSON( image ){

        var uuid = THREE.Math.generateUUID();

        var json = {
            uuid: uuid,
            data: getDataURL( image ),
        };

        return json;


        function getDataURL( image ){

            var canvas;

            if ( image.toDataURL !== undefined ) {

                canvas = image;

            } else {

                canvas = document.createElementNS( "http://www.w3.org/1999/xhtml", "canvas" );
                canvas.width = image.width;
                canvas.height = image.height;
                canvas.getContext( "2d" ).drawImage( image, 0, 0, image.width, image.height );

            }

            if ( canvas.width > 2048 || canvas.height > 2048 ) {

                return canvas.toDataURL( "image/jpeg", 0.6 );

            } else {

                return canvas.toDataURL( "image/png" );
            }

        }

    }



//  IMAGE FROM JSON.
//  Return a promise with the image resolved.

    async function imagefromJSON( json, onImageLoad ){

        var img = new Image();
        img.crossOrigin = "anonymous";

        if ( onImageLoad ) {
            img.addEventListener("load", onImageLoad);
        }

        img.src = json.data;

        return img;

    }

</script>

<script>

    $("#control-tab").load("./components/control-tab.html");
    $("#helpers-tab").load("./components/helpers-tab.html");
//  $("#assets-tab").load("/assets/office_building.html");

</script>


</body>
</html>



<script>

//  CACHE MATCAPS.

/*
    caches.open("matcaps").then(function(cache){

        var matcaps = [];
        for (var i = 1; i < 10; i++ ){
            matcaps.push(`./matcap/matcap_00${i}.jpg`)
        }

        for ( i; i < 100; i++ ){
            matcaps.push(`./matcap/matcap_0${i}.jpg`);
        }

        for ( i; i < 109; i++ ){
            matcaps.push(`./matcap/matcap_${i}.jpg`);
        }

        debugMode && console.log( "matcaps:", matcaps );
        
        cache.addAll(matcaps).catch( function(err){
            console.error(err);
        });

    });
*/
/*
    var matcaps = [
        "./matcap/matcap_001.jpg", "./matcap/matcap_002.jpg", "./matcap/matcap_003.jpg", "./matcap/matcap_004.jpg", "./matcap/matcap_005.jpg", "./matcap/matcap_006.jpg", "./matcap/matcap_007.jpg", 
        "./matcap/matcap_008.jpg", "./matcap/matcap_009.jpg", "./matcap/matcap_010.jpg", "./matcap/matcap_011.jpg", "./matcap/matcap_012.jpg", "./matcap/matcap_013.jpg", "./matcap/matcap_014.jpg", 
        "./matcap/matcap_015.jpg", "./matcap/matcap_016.jpg", "./matcap/matcap_017.jpg", "./matcap/matcap_018.jpg", "./matcap/matcap_019.jpg", "./matcap/matcap_020.jpg", "./matcap/matcap_021.jpg", 
        "./matcap/matcap_022.jpg", "./matcap/matcap_023.jpg", "./matcap/matcap_024.jpg", "./matcap/matcap_025.jpg", "./matcap/matcap_026.jpg", "./matcap/matcap_027.jpg", "./matcap/matcap_028.jpg", 
        "./matcap/matcap_029.jpg", "./matcap/matcap_030.jpg", "./matcap/matcap_031.jpg", "./matcap/matcap_032.jpg", "./matcap/matcap_033.jpg", "./matcap/matcap_034.jpg", "./matcap/matcap_035.jpg", 
        "./matcap/matcap_036.jpg", "./matcap/matcap_037.jpg", "./matcap/matcap_038.jpg", "./matcap/matcap_039.jpg", "./matcap/matcap_040.jpg", "./matcap/matcap_041.jpg", "./matcap/matcap_042.jpg", 
        "./matcap/matcap_043.jpg", "./matcap/matcap_044.jpg", "./matcap/matcap_045.jpg", "./matcap/matcap_046.jpg", "./matcap/matcap_047.jpg", "./matcap/matcap_048.jpg", "./matcap/matcap_049.jpg", 
        "./matcap/matcap_050.jpg", "./matcap/matcap_051.jpg", "./matcap/matcap_052.jpg", "./matcap/matcap_053.jpg", "./matcap/matcap_054.jpg", "./matcap/matcap_055.jpg", "./matcap/matcap_056.jpg", 
        "./matcap/matcap_057.jpg", "./matcap/matcap_058.jpg", "./matcap/matcap_059.jpg", "./matcap/matcap_060.jpg", "./matcap/matcap_061.jpg", "./matcap/matcap_062.jpg", "./matcap/matcap_063.jpg", 
        "./matcap/matcap_064.jpg", "./matcap/matcap_065.jpg", "./matcap/matcap_066.jpg", "./matcap/matcap_067.jpg", "./matcap/matcap_068.jpg", "./matcap/matcap_069.jpg", "./matcap/matcap_070.jpg", 
        "./matcap/matcap_071.jpg", "./matcap/matcap_072.jpg", "./matcap/matcap_073.jpg", "./matcap/matcap_074.jpg", "./matcap/matcap_075.jpg", "./matcap/matcap_076.jpg", "./matcap/matcap_077.jpg", 
        "./matcap/matcap_078.jpg", "./matcap/matcap_079.jpg", "./matcap/matcap_080.jpg", "./matcap/matcap_081.jpg", "./matcap/matcap_082.jpg", "./matcap/matcap_083.jpg", "./matcap/matcap_084.jpg", 
        "./matcap/matcap_085.jpg", "./matcap/matcap_086.jpg", "./matcap/matcap_087.jpg", "./matcap/matcap_088.jpg", "./matcap/matcap_089.jpg", "./matcap/matcap_090.jpg", "./matcap/matcap_091.jpg", 
        "./matcap/matcap_092.jpg", "./matcap/matcap_093.jpg", "./matcap/matcap_094.jpg", "./matcap/matcap_095.jpg", "./matcap/matcap_096.jpg", "./matcap/matcap_097.jpg", "./matcap/matcap_098.jpg", 
        "./matcap/matcap_099.jpg", "./matcap/matcap_100.jpg", "./matcap/matcap_101.jpg", "./matcap/matcap_102.jpg", "./matcap/matcap_103.jpg", "./matcap/matcap_104.jpg", "./matcap/matcap_105.jpg", 
        "./matcap/matcap_106.jpg", "./matcap/matcap_107.jpg", "./matcap/matcap_108.jpg",
    ];
*/

//  INSTALL MATCAPS.

/*
    matcaps.forEach(function(url){
        fetch(url).then(function(response){

            return response.blob();

        }).then(function(blob){

            return new Promise(function(resolve, reject){
                var reader = new FileReader();
                reader.addEventListener("loadend", function(e){
                    var name = url.split(".");
                    name.pop(); 
                    name = name.join("");
                    name = name.split("/").pop();
                    resolve({
                        size:blob.size,
                        type:blob.type,
                        data:reader.result,
                        _id: name,
                    });
                });

                reader.readAsDataURL(blob);
            });

        }).then(function(data){
            debugMode && console.log(data);

            db.collection("matcap")
            .insert(data, function(err){
                if (err) throw err;
            }).catch(function(err){
                debugMode && console.error(err);
            });

        });
    
    });
*/

</script>

<script>
/*
    var female = {};

    female.skeleton = {
        name: "skeleton",
        scale: [1,1,1],
        visible: false,
        geometry: "/skinned/HF_Skeleton_FBK06v7.json",
        materials: [{
            type: "MeshStandardMaterial",
            options: {
                side: 0,
                opacity: 1,
                shading: 2,
                metalness: 0.5,
                roughness: 0.5,
                skinning: true,
                bumpScale: -0.05,
                color: 16777215,
                emissive: 8223097,
                transparent: true,
                emissiveIntensity: 1,
                name: "HF_SkeletonMaterial",
            },
        }],
    };

    w3.getHttpObject(female.skeleton.geometry, function( json ){
        json._id = "skeleton";
        db.collection("female").insert(json);
    });

    female.body = {
        name: "body",
        scale: [1,1,1],
        visible: true,
        geometry: "/skinned/FM_Body_FBK06v7.json",
        materials: [{
            type: "MeshStandardMaterial",
            map: "https://i.imgur.com/pRYCYkb.jpg",
            emissiveMap: "https://i.imgur.com/jc8chBX.jpg",
            options: {
                side: 0,
                opacity: 1,
                shading: 2,
                metalness: 0,
                roughness: 0.6,
                skinning: true,
                color: 16777215,
                emissive: 11776690,
                transparent: false,
                emissiveIntensity: 1,
                name: "HF_SkinMaterial",
            },
        }, {
            type: "MeshStandardMaterial",
            map: "https://i.imgur.com/Si5QWl0.png",
            emissiveMap: "https://i.imgur.com/Si5QWl0.png",
            options: {
                side: 0,
                opacity: 1,
                shading: 2,
                metalness: 0.5,
                roughness: 0.5,
                skinning: true,
                color: 16777215,
                emissive: 9276813,
                transparent: false,
                emissiveIntensity: 1,
                name: "HF_EyesMaterial",
            },
        }],
    };

//    w3.getHttpObject(female.body.geometry, function( json ){
//        json._id = "body";
//        db.collection("female").insert(json);
//    });

    female.underwears = {
        name: "underwears",
        scale: [1,1,1],
        visible: false,
        geometry: "/skinned/FM_Underwears_FBK06v8.json",
        materials: [{
            type: "MeshStandardMaterial",
            options: {
                side: 0,
                opacity: 1,
                shading: 2,
                metalness: 0.5,
                roughness: 0.5,
                skinning: true,
                bumpScale: -0.05,
                color: 16777215,
                emissive: 8223097,
                transparent: true,
                emissiveIntensity: 1,
                name: "HF_UnderwearsMaterial",
            },
        }],
    };

//    w3.getHttpObject(female.underwears.geometry, function( json ){
//        json._id = "underwears";
//        db.collection("female").insert(json);
//    });

    female.stockings = {
        name: "stockings",
        scale: [1,1,1],
        visible: false,
        geometry: "/skinned/FM_Stockings_FBK06v7.json",
        materials: [{
            type: "MeshStandardMaterial",
            options: {
                side: 0,
                opacity: 1,
                shading: 2,
                metalness: 0.5,
                roughness: 0.5,
                skinning: true,
                bumpScale: -0.05,
                color: 16777215,
                emissive: 8223097,
                transparent: true,
                emissiveIntensity: 1,
                name: "HF_StockingsMaterial",
            },
        }],
    };

//    w3.getHttpObject(female.stockings.geometry, function( json ){
//        json._id = "stockings";
//        db.collection("female").insert(json);
//    });

    female.costume = {
        name: "costume",
        scale: [1,1,1],
        visible: false,
        geometry: "/skinned/FM_Uniform_FBK06v7.json",
        materials: [{
            type: "MeshStandardMaterial",
            options: {
                side: 0,
                opacity: 1,
                shading: 2,
                metalness: 0.5,
                roughness: 0.5,
                skinning: true,
                bumpScale: -0.05,
                color: 16777215,
                emissive: 8223097,
                transparent: true,
                emissiveIntensity: 1,
                name: "HF_UniformMaterial",
            },
        }],
    };

//    w3.getHttpObject(female.costume.geometry, function( json ){
//        json._id = "costume";
//        db.collection("female").insert(json);
//    });

    female.dress = {
        name: "dress",
        scale: [1,1,1],
        visible: false,
        geometry: "/skinned/FM_Dress_FBK06v7.json",
        materials: [{
            type: "MeshStandardMaterial",
            options: {
                side: 0,
                opacity: 1,
                shading: 2,
                metalness: 0.5,
                roughness: 0.5,
                skinning: true,
                bumpScale: -0.05,
                color: 16777215,
                emissive: 8223097,
                transparent: true,
                emissiveIntensity: 1,
                name: "HF_DressMaterial",
            },
        }],
    };

//    w3.getHttpObject(female.dress.geometry, function( json ){
//        json._id = "dress";
//        db.collection("female").insert(json);
//    });
*/
    
</script>

<script>

/*
    var female = {};

    w3.getHttpObject(female.body.geometry, function( json ){
        var body = initSkinnedAsset( json );

    //  Asset map options.

    //  Set imgur url.

    //  Load textures.
        (function(){
            var url = female.body.materials[0].map;
            var options = female.body.materials[0].options;

            var img = new Image(512,512);
            img.crossOrigin = "anonymous"; // !important: "anonymous"
            $(img).on("load", function(){
                //  var canvas = makePowerOfTwo( img );
                var texture = new THREE.Texture(img); // img or canvas //
                body.material.materials[0].map = texture;
                body.material.materials[0].color.setHex( options.color );
                body.material.materials[0].map.needsUpdate = true;
                body.material.materials[0].needsUpdate = true;
            });
            img.src = url;
        })();

        (function(){
            var url = female.body.materials[0].emissiveMap;
            var options = female.body.materials[0].options;

            var img = new Image(512,512);
            img.crossOrigin = "anonymous"; // !important: "anonymous"
            $(img).on("load", function(){
                //  var canvas = makePowerOfTwo( img );
                var texture = new THREE.Texture(img); // img or canvas //
                body.material.materials[0].emissiveMap = texture;
                body.material.materials[0].emissive.setHex( options.emissive );
                body.material.materials[0].emissiveMap.needsUpdate = true;
                body.material.materials[0].needsUpdate = true;
            });
            img.src = url;
        })();

        (function(){
            var url = female.body.materials[1].map;
            var options = female.body.materials[1].options;

            var img = new Image(128,128);
            img.crossOrigin = "anonymous"; // !important: "anonymous"
            $(img).on("load", function(){
                //  var canvas = makePowerOfTwo( img );
                var texture = new THREE.Texture(img); // img or canvas //
                body.material.materials[1].map = texture;
                body.material.materials[1].color.setHex( options.color );
                body.material.materials[1].map.needsUpdate = true;
                body.material.materials[1].needsUpdate = true;
            });
            img.src = url;
        })();

        (function(){
            var url = female.body.materials[1].emissiveMap;
            var options = female.body.materials[1].options;

            var img = new Image(128,128);
            img.crossOrigin = "anonymous"; // !important: "anonymous"
            $(img).on("load", function(){
                //  var canvas = makePowerOfTwo( img );
                var texture = new THREE.Texture(img); // img or canvas //
                body.material.materials[1].emissiveMap = texture;
                body.material.materials[1].emissive.setHex( options.emissive );
                body.material.materials[1].emissiveMap.needsUpdate = true;
                body.material.materials[1].needsUpdate = true;
            });
            img.src = url;
        })();

        localPlayer.outfit.add({body: body});

    }).then(function(outfit){
        debugMode && console.log("outfit:", outfit);
        localPlayer.holder.visible = false;
    });

    w3.getHttpObject(female.underwears.geometry, function( json ){
        var lingerie = initSkinnedAsset( json );
        localPlayer.outfit.add({lingerie: lingerie});
    });

    w3.getHttpObject(female.stockings.geometry, function( json ){
        var stockings = initSkinnedAsset( json );
        localPlayer.outfit.add({stocking: stockings});
    });

    w3.getHttpObject(female.costume.geometry, function( json ){
        var costume = initSkinnedAsset( json );
        localPlayer.outfit.add({costume: costume});
    });

    w3.getHttpObject(female.dress.geometry, function( json ){
        var dress = initSkinnedAsset( json );
        localPlayer.outfit.add({dress: dress});
    });
*/

/*
    db.collection("female").findOne({_id:"body"}).then(function(json){
        var body = initSkinnedAsset( json );

        var loader = new THREE.TextureLoader();

        body.material.materials[0].map = loader.load("https://i.imgur.com/pRYCYkb.jpg");
        body.material.materials[0].emissiveMap = loader.load("https://i.imgur.com/jc8chBX.jpg");

        body.material.materials[0].map.sourceFile = "https://i.imgur.com/pRYCYkb.jpg";         // !important
        body.material.materials[0].emissiveMap.sourceFile = "https://i.imgur.com/jc8chBX.jpg"; // !important

        body.material.materials[0].color.setHex(16777215);
        body.material.materials[0].emissive.setHex(11776690);

        body.material.materials[1].map = 
        body.material.materials[1].emissiveMap = loader.load("https://i.imgur.com/Si5QWl0.png");

        body.material.materials[1].map.sourceFile = 
        body.material.materials[1].emissiveMap.sourceFile = "https://i.imgur.com/Si5QWl0.png";         // !important

        body.material.materials[1].color.setHex(16777215);
        body.material.materials[1].emissive.setHex(9276813);

        body.material.materials[0].needsUpdate = true;
        body.material.materials[1].needsUpdate = true;

        return localPlayer.outfit.add( {body: body} );

    }).then(function(outfit){
        debugMode && console.log("outfit:", outfit);
        localPlayer.holder.visible = false;
    });
*/

    /*
        var loader = new THREE.TextureLoader();
        localPlayer.outfit.body.material.materials[0].map = loader.load("https://i.imgur.com/pRYCYkb.jpg");
        localPlayer.outfit.body.material.materials[0].emissiveMap = loader.load("https://i.imgur.com/jc8chBX.jpg");
        localPlayer.outfit.body.material.materials[0].color.setHex(16777215);
        localPlayer.outfit.body.material.materials[0].emissive.setHex(11776690);

        localPlayer.outfit.body.material.materials[1].map = 
        localPlayer.outfit.body.material.materials[1].emissiveMap = loader.load("https://i.imgur.com/Si5QWl0.png");
        localPlayer.outfit.body.material.materials[1].color.setHex(16777215);
        localPlayer.outfit.body.material.materials[1].emissive.setHex(9276813);

        localPlayer.outfit.body.material.materials[0].needsUpdate = true;
        localPlayer.outfit.body.material.materials[1].needsUpdate = true;
    */

/*
    db.collection("female").findOne({_id:"body"}).then(function(json){
        return initSkinnedAsset( json );
    }).then(function( body ){

        new Promise(function(resolve, reject){
            var img = new Image(512,512);
            img.crossOrigin = "anonymous"; // !important: "anonymous"
            $(img).on("load", function(){
                var texture = new THREE.Texture(img); // img or canvas //
                body.material.materials[0].map = texture;
                body.material.materials[0].color.setHex( 16777215 );
                body.material.materials[0].emissive.setHex(11776690);
                body.material.materials[0].map.needsUpdate = true;
                body.material.materials[0].needsUpdate = true;
                resolve( texture );
            });
            img.src = "https://i.imgur.com/pRYCYkb.jpg";
        }).then(function( texture ){
        //  TEXTURE IMAGE TO DATAURL.
            var canvas = document.createElement( "canvas" );
            canvas.width = texture.image.width;
            canvas.height = texture.image.height;
            var context = canvas.getContext( "2d" );
            context.drawImage( texture.image, 0, 0, canvas.width, canvas.height );
            return canvas.toDataURL();
        }).then(function(data){
            console.log(data);
        });

        return localPlayer.outfit.add( {body: body} );

    }).then(function(outfit){
        debugMode && console.log("outfit:", outfit);
        localPlayer.holder.visible = false;
    });
*/

/*
    var images = ([
        "https://i.imgur.com/pRYCYkb.jpg",
        "https://i.imgur.com/jc8chBX.jpg",
        "https://i.imgur.com/Si5QWl0.png",
    ];

    caches.open("images").then(function(cache){
        cache.addAll(images);
    });

    var geometries = [
        "/skinned/HF_Skeleton_FBK06v7.json",
        "/skinned/FM_Body_FBK06v7.json",
        "/skinned/FM_Underwears_FBK06v7.json",
        "/skinned/FM_Stockings_FBK06v7.json",
        "/skinned/FM_Uniform_FBK06v7.json",
        "/skinned/FM_Dress_FBK06v7.json",
    ];

    caches.open("geometries").then(function(cache){
        cache.addAll(geometries);
    });
*/

/*

//  ADD MATERIAL JSON TO DATABASE.

    var json = localPlayer.outfit.body.material.toJSON();

    json._id = "HF_BodyMaterial"; // !important

    db.collection("materials").insert(json, function(err){
        if (err) throw err;
    }).catch(function(err){
        console.error(err);
    });

    json.materials[0]._id = json.materials[0].name;
    json.materials[1]._id = json.materials[1].name;
    db.collection("materials").insert(json.materials);

    json.materials[0].textures[0]._id = json.materials[0].textures[0].uuid;
    json.materials[0].textures[1]._id = json.materials[0].textures[1].uuid;
    json.materials[1].textures[0]._id = json.materials[1].textures[0].uuid;
    db.collection("textures").insert(json.materials[0].textures);
    db.collection("textures").insert(json.materials[1].textures);

    json.materials[0].images[0]._id = json.materials[0].images[0].uuid;
    json.materials[0].images[1]._id = json.materials[0].images[1].uuid;
    json.materials[1].images[0]._id = json.materials[1].images[0].uuid;
    db.collection("images").insert(json.materials[0].images);
    db.collection("images").insert(json.materials[1].images);

*/

</script>

<script>

/*
//  THREE.Texture.toJSON() DEBUG.

    THREE.Texture.toJSON: function ( meta ) {


		if ( meta.textures[ this.uuid ] !== undefined ) {
            return meta.textures[ this.uuid ];
		}

		var output = {
			metadata: {
				version: 4.4,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			mapping: this.mapping,

			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			wrap: [ this.wrapS, this.wrapT ],

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy
		};

		if ( this.image !== undefined ) {

			// TODO: Move to THREE.Image

			var image = this.image;

			if ( image.uuid === undefined ) {

				image.uuid = THREE.Math.generateUUID(); // UGH

			}

			if ( meta.images[ image.uuid ] === undefined ) {

				meta.images[ image.uuid ] = {
					uuid: image.uuid,
					url: image.src || getDataURL( image ), // default: dataURL.
				//  CUSTOM MODIFY: replace dataURL with image.src. //
				//	url: image.src  // modified // 
				};

			}

			output.image = image.uuid;

		}

		meta.textures[ this.uuid ] = output;

		return output;

		function getDataURL( image ) {

			var canvas;

			if ( image.toDataURL !== undefined ) {

				canvas = image;

			} else {

				canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
				canvas.width = image.width;
				canvas.height = image.height;

				canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

			}

			if ( canvas.width > 2048 || canvas.height > 2048 ) {

				return canvas.toDataURL( 'image/jpeg', 0.6 );

			} else {

				return canvas.toDataURL( 'image/png' );

			}

		}

	}

//  FIX.

	THREE.Texture.toJSON: function ( meta ) {

		var isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

			return meta.textures[ this.uuid ];

		}

		var output = {

			metadata: {
				version: 4.5,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			mapping: this.mapping,

			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			center: [ this.center.x, this.center.y ],
			rotation: this.rotation,

			wrap: [ this.wrapS, this.wrapT ],

			format: this.format,
			type: this.type,
			encoding: this.encoding,

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,

			flipY: this.flipY,

			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment

		};

		if ( this.image !== undefined ) {

			// TODO: Move to THREE.Image

			var image = this.image;

			if ( image.uuid === undefined ) {

				image.uuid = _Math.generateUUID(); // UGH

			}

			if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {

				var url;

				if ( Array.isArray( image ) ) {

					// process array of images e.g. CubeTexture

					url = [];

					for ( var i = 0, l = image.length; i < l; i ++ ) {

						url.push( getDataURL( image[ i ] ) );

					}

				} else {

					// process single image

					url = getDataURL( image );

				}

				meta.images[ image.uuid ] = {
					uuid: image.uuid,
					url: url
				};

			}

			output.image = image.uuid;

		}

		if ( ! isRootObject ) {

			meta.textures[ this.uuid ] = output;

		}

		return output;

		function getDataURL( image ) {

			var canvas;

			if ( image.toDataURL !== undefined ) {

				canvas = image;

			} else {

				canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
				canvas.width = image.width;
				canvas.height = image.height;

				canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

			}

			if ( canvas.width > 2048 || canvas.height > 2048 ) {

				return canvas.toDataURL( 'image/jpeg', 0.6 );

			} else {

				return canvas.toDataURL( 'image/png' );

			}

		}

	}

*/
</script>


<script>

//  TO JSON.
/*
    async function textureToJson( texture ){
        if (!texture) return;

        var json = {};

        Object.keys(texture).forEach(function( name ){

            if ( name == "_listeners" ) return;
            if (texture[ name ] == undefined) return;

            switch (name){

                default:
                    json[ name ] = texture[ name ];
                break;

                case "uuid":
                    json[ name ] = texture[ name ] || THREE.Math.generateUUID();
                break;

                case "offset":
                case "repeat":
                    if ( !(texture[ name ] instanceof THREE.Vector2) ) return;
                    json[ name ] = texture[ name ].toArray();
                break;

                case "mipmaps":
                    if ( !(texture[ name ] instanceof Array) ) return;
                    if ( texture[ name ].length == 0 ) return;
                    json[ name ] = texture[ name ];
                break;

                case "image":

                //  getDataURL.

                    var canvas;
                    var image = texture[ name ];

                    if ( image.toDataURL !== undefined ) {
                        canvas = image;
                    } else {
                        canvas = document.createElementNS( "http://www.w3.org/1999/xhtml", "canvas" );
                        canvas.width = image.width;
                        canvas.height = image.height;
                        canvas.getContext( "2d" ).drawImage( image, 0, 0, image.width, image.height );
                    }

                    if ( canvas.width > 2048 || canvas.height > 2048 ) {
                        json[ name ] = canvas.toDataURL( "image/jpeg", 0.6 );
                    } else {
                        json[ name ] = canvas.toDataURL( "image/png" );
                    }

                break;

            }

        });

        return json;

    }


    async function textureFromJson( json ){
        if (!json) return;

        var texture = new THREE.Texture();
        Object.keys(json).forEach(function( name ){

            switch (name){

                default:
                    texture[ name ] = json[ name ];
                break;

                case "offset":
                case "repeat":
                    if ( json[ name ].length != 2) return;
                    texture[ name ] = new THREE.Vector2();
                    texture[ name ].fromArray( json[ name ] );
                break;

                case "wrap":
                    if ( json[ name ].length != 2) return;
                    if ( !(json[ name ] instanceof Array) ) return;
                    texture.wrapS = json[ name ][0];
                    texture.wrapT = json[ name ][1];
                break;

                case "image":
                    var image = new Image();
                    image.onload = function(){ texture.needsUpdate = true; };
                    image.src = json[ name ];
                    texture[ name ] = image;
                break;

            }

        });

        return texture;
    }


    async function materialToJson( material ){

        if (!material) return;

        var json = {};

        Object.keys(material).forEach(function( name ){

            if ( name == "defines" ) return;
            if ( name == "program" ) return;
            if ( name == "_listeners" ) return;
            if ( name == "_needsUpdate" ) return;
            if ( name == "__webglShader" ) return;
            if ( material[ name ] == undefined ) return;
            if ( material[ name ] instanceof Function ) return;

            switch( name ){

                case "uuid":
                    json.uuid = material.uuid || THREE.Math.generateUUID();
                break;

                default:
                    json[ name ] = material[ name ];
                break;

            //  THREE.Texture (to JSON)
                case "alphaMap":
                case "aoMap":
                case "bumpMap":
                case "displacementMap":
                case "emissiveMap":
                case "lightMap":
                case "map":
                case "metalnessMap":
                case "normalMap":
                case "roughnessMap":
                case "specularMap":

                    if ( !(material[ name ] instanceof THREE.Texture) ) 
                        throw `${name} is not instance of THREE.Texture`;

                    textureToJson( material[ name ] ).then(function( result ){
                        json[ name ] = result;
                    });

                break;

            //  THREE.Color (get HEX)
                case "color":
                case "emissive":
                case "specular":

                    if ( !(material[ name ] instanceof THREE.Color) ) 
                        throw `${name} is not instance of THREE.Color`;

                    json[ name ] = material[ name ].getHex();

                break;

            //  THREE.Vector2 (to ARRAY)
                case "normalScale":

                    if ( !(material[ name ] instanceof THREE.Vector2) ) 
                        throw `${name} is not instance of THREE.Vector2`;

                    json[ name ] = material[ name ].toArray();

                break;

            //  THREE.CubeTexture
                case "envMap":
                    // TODO //
                break;

            }

        });

        return json;

    }

    async function materialFromJson( json ){

        if (!json) return;

        var options = {};

        for (var name in json){

            switch (name){

                case "uuid":
                    options.uuid = json.uuid || THREE.Math.generateUUID();
                break;

            //  THREE.Texture (from JSON)
                case "alphaMap":
                case "aoMap":
                case "bumpMap":
                case "displacementMap":
                case "emissiveMap":
                case "lightMap":
                case "map":
                case "metalnessMap":
                case "normalMap":
                case "roughnessMap":
                case "specularMap":

                    await textureFromJson( json[ name ] )
                    .then(function( result ){
                        options[ name ] = result;
                        debugMode && console.log( `options.${name}:`, options[ name ] );
                    });

                break;

            //  THREE.Color (set HEX)
                case "color":
                case "emissive":
                case "specular":

                    options[ name ] = new THREE.Color();
                    options[ name ].setHex( json[ name ] );

                break;

            //  THREE.Vector2 (from ARRAY)
                case "normalScale":

                    options[ name ] = new THREE.Vector2();
                    options[ name ].fromArray( json[ name ] );

                break;

            //  THREE.CubeTexture
                case "envMap":
                    // TODO //
                break;

                default:
                    options[ name ] = json[ name ];
            }

        }

        debugMode && console.log( "options:", options );
        
        return new THREE[ options.type ](options);

    }
*/

</script>


<script>

/*
    //  GET MATERIAL JSON FROM DATABASE.

        if ( json.type == "Multimaterial" ) {

            json.materials.forEach(function( material ){


            });

        } else {

            var textures = json.textures;
            textures.forEach(function( item, i ){

            });

            var images = json.images;
            images.forEach(function( item, i ){

            });

        }

*/

/*
    new THREE.Texture();
        anisotropy: 1
        encoding: 3000
        flipY: true
        format: 1021
        generateMipmaps: true
        image: undefined
        magFilter: 1006
        mapping: 300
        minFilter: 1008
        mipmaps: []
        name: ""
        offset: THREE.Vector2 {x: 0, y: 0}
        premultiplyAlpha: false
        repeat: THREE.Vector2 {x: 1, y: 1}
        sourceFile: ""
        type: 1009
        unpackAlignment: 4
        uuid: "B34A28B5-75C7-423E-852C-F93EF020B082"
        version: 0
        wrapS: 1001
        wrapT: 1001
*/

/*
    new THREE.MeshStandardMaterial().
        alphaMap: null
        alphaTest: 0
        aoMap: null
        aoMapIntensity: 1
        blendDst: 205
        blendDstAlpha: null
        blendEquation: 100
        blendEquationAlpha: null
        blendSrc: 204
        blendSrcAlpha: null
        blending: 1
        bumpMap: null
        bumpScale: 1
        clipShadows: false
        clippingPlanes: null
        color: THREE.Color {r: 1, g: 1, b: 1}
        colorWrite: true
        defines: {STANDARD: ""}
        depthFunc: 3
        depthTest: true
        depthWrite: true
        displacementBias: 0
        displacementMap: null
        displacementScale: 1
        emissive: THREE.Color {r: 0, g: 0, b: 0}
        emissiveIntensity: 1
        emissiveMap: null
        envMap: null
        envMapIntensity: 1
        fog: true
        lightMap: null
        lightMapIntensity: 1
        lights: true
        map: null
        metalness: 0.5
        metalnessMap: null
        morphNormals: false
        morphTargets: false
        name: ""
        normalMap: null
        normalScale: THREE.Vector2 {x: 1, y: 1}
        opacity: 1
        overdraw: 0
        polygonOffset: false
        polygonOffsetFactor: 0
        polygonOffsetUnits: 0
        precision: null
        premultipliedAlpha: false
        refractionRatio: 0.98
        roughness: 0.5
        roughnessMap: null
        shading: 2
        side: 0
        skinning: false
        transparent: false
        type: "MeshStandardMaterial"
        uuid: "A6922091-380E-4307-B090-83EE5B377428"
        vertexColors: 0
        visible: true
        wireframe: false
        wireframeLinecap: "round"
        wireframeLinejoin: "round"
        wireframeLinewidth: 1

*/

/*
    async function textureToJson( texture ){
        if (!texture) return;

        var json = {};

        if (texture.anisotropy != undefined) json.anisotropy = texture.anisotropy;
        if (texture.encoding != undefined) json.encoding = texture.encoding;
        if (texture.flipY != undefined) json.flipY = texture.flipY;
        if (texture.format != undefined) json.format = texture.format;
        if (texture.generateMipmaps != undefined) json.generateMipmaps = texture.generateMipmaps;
        if (texture.magFilter != undefined) json.magFilter = texture.magFilter;
        if (texture.mapping != undefined) json.mapping = texture.mapping;
        if (texture.minFilter != undefined) json.minFilter = texture.minFilter;
        if (texture.name != undefined) json.name = texture.name;
        if (texture.premultiplyAlpha != undefined) json.premultiplyAlpha = texture.premultiplyAlpha;
        if (texture.sourceFile != undefined) json.sourceFile = texture.sourceFile;
        if (texture.unpackAlignment != undefined) json.unpackAlignment = texture.unpackAlignment;
        if (texture.wrapS != undefined) json.wrapS = texture.wrapS;
        if (texture.wrapT != undefined ) json.wrapT = texture.wrapT;

        if (texture.mipmaps != undefined && texture.mipmaps instanceof Array && texture.mipmaps.length > 0)
            json.mipmaps = texture.mipmaps;
        if (texture.offset != undefined && texture.offset instanceof THREE.Vector2)
            json.offset = texture.offset.toArray();
        if (texture.repeat != undefined && texture.repeat instanceof THREE.Vector2)
            json.repeat = texture.repeat.toArray();

        json.uuid = texture.uuid || THREE.Math.generateUUID();


        if (texture.image != undefined){

        //  getDataURL.

            var canvas;
            var image = texture.image;

            if ( image.toDataURL !== undefined ) {
                canvas = image;
            } else {
                canvas = document.createElementNS( "http://www.w3.org/1999/xhtml", "canvas" );
                canvas.width = image.width;
                canvas.height = image.height;
                canvas.getContext( "2d" ).drawImage( image, 0, 0, image.width, image.height );
            }

            if ( canvas.width > 2048 || canvas.height > 2048 ) {
                json.image = canvas.toDataURL( "image/jpeg", 0.6 );
            } else {
                json.image = canvas.toDataURL( "image/png" );
            }

        }

        return json;

    }
*/

</script>
